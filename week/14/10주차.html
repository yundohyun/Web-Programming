<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css"
    />
    <link rel="stylesheet" href="/style/code.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <title>Document</title>
  </head>
  <body>
    <h1>10주차</h1>
    <pre>
      <code class="language-javascript">
    &#x2F;&#x2F; 1. 다음 refer의 첫번째요소 값을 s로 바꾸시오.
    const arr &#x3D; [{ a: &quot;a&quot; }, { b: &quot;b&quot; }];
    const refer &#x3D; arr;
    arr[0].a &#x3D; &quot;s&quot;;

    &#x2F;&#x2F; 2. 1번의 arr의 첫번째 값과 refer의 첫번째 값을 비교하는 명령문을 쓰시오.
    document.write(arr[0].a &#x3D;&#x3D; refer[0].a ? &quot;same&quot; : &quot;diff&quot; + &quot;&lt;br&gt;&quot;);

    &#x2F;&#x2F; 3. 1번의 refer변수에 arr를 복사할 때 같은 복사명령문으로 복사하는 명령문을 쓰시오.
    const refer_ &#x3D; arr;

    &#x2F;&#x2F; 4. 다음 deep변수에 a변수값에 대해 깊은 복사하시오.
    &#x2F;*
      let a &#x3D;{
        name:&#39;강아지&#39;,
      };
    *&#x2F;
    const a_ &#x3D; { name: &quot;강아지&quot; };
    const deep &#x3D; JSON.parse(JSON.stringify(a_));

    &#x2F;&#x2F; 5. arr배열을 a,b,c 에 구조분해할당하시오.
    const arr &#x3D; [1, 2, 3];
    let [a, b, c] &#x3D; arr;

    &#x2F;&#x2F; 6. 5번에서 만든 a과 b의 값을 구조분해할당을 이용하여 바꾸시오.
    [a, b] &#x3D; [b, a];

    &#x2F;&#x2F; 7. 다음 for문을 forEach문을 이용하여 변경하시오.
    &#x2F;*
    const arr &#x3D; [1, 2, 3, 4, 5];
      for (let i &#x3D; 0; i &lt; arr.length; i++)
        document.write(&quot; &quot; + arr[i]);
    *&#x2F;
    const arr &#x3D; [1, 2, 3, 4, 5];
    arr.forEach((v) &#x3D;&gt; document.write(&quot; &quot; + v));

    &#x2F;&#x2F; 8. 파라미터 2개를 리턴하는 createM함수를 만드시오.
    &#x2F;*
      let monster &#x3D; creatM(&#39;monster&#39;,100);
    *&#x2F;
    const creatM &#x3D; (name, hp) &#x3D;&gt; ({ name, hp });

    &#x2F;&#x2F; 9. 8번의 createM함수를 class로 변경하시오.
    class Monster {
      constructor(name, hp) {
        this.name &#x3D; name;
        this.hp &#x3D; hp;
      }
    }

    &#x2F;&#x2F; 10. 9번에서 만든 class의 하나의 객체를 만드시오.
    const monster &#x3D; new Monster(&quot;monster&quot;, 100);
      </code>
    </pre>
    <script>
      // https://www.w3docs.com/tools/html-encoder/
      hljs.highlightAll();
      if (new URL(location.href).searchParams.get("hidden") == "true")
        document.querySelector("body > pre").style.display = "none";
    </script>
    <script>
      // 1. 다음 refer의 첫번째요소 값을 s로 바꾸시오.
      const arr = [{ a: "a" }, { b: "b" }];
      const refer = arr;
      arr[0].a = "s";

      // 2. 1번의 arr의 첫번째 값과 refer의 첫번째 값을 비교하는 명령문을 쓰시오.
      document.write(arr[0].a == refer[0].a ? "same" : "diff" + "<br>");

      // 3. 1번의 refer변수에 arr를 복사할 때 같은 복사명령문으로 복사하는 명령문을 쓰시오.
      const refer_ = arr;

      // 4. 다음 deep변수에 a변수값에 대해 깊은 복사하시오.
      /*
        let a ={
          name:'강아지',
        };
      */
      const a_ = { name: "강아지" };
      const deep = JSON.parse(JSON.stringify(a_));

      // 5. arr배열을 a,b,c 에 구조분해할당하시오.
      const arr = [1, 2, 3];
      let [a, b, c] = arr;

      // 6. 5번에서 만든 a과 b의 값을 구조분해할당을 이용하여 바꾸시오.
      [a, b] = [b, a];

      // 7. 다음 for문을 forEach문을 이용하여 변경하시오.
      /*
      const arr = [1, 2, 3, 4, 5];
        for (let i = 0; i < arr.length; i++)
          document.write(" " + arr[i]);
      */
      const arr = [1, 2, 3, 4, 5];
      arr.forEach((v) => document.write(" " + v));

      // 8. 파라미터 2개를 리턴하는 createM함수를 만드시오.
      /*
        let monster = creatM('monster',100);
      */
      const creatM = (name, hp) => ({ name, hp });

      // 9. 8번의 createM함수를 class로 변경하시오.
      class Monster {
        constructor(name, hp) {
          this.name = name;
          this.hp = hp;
        }
      }

      // 10. 9번에서 만든 class의 하나의 객체를 만드시오.
      const monster = new Monster("monster", 100);
    </script>
  </body>
</html>
